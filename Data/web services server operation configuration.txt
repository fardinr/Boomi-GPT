to build and publish an api powered by integration, you need to understand the basics of our web services server connector and how to build an operation. the web services server operation allows you to define a single object and operation type that controls: the required structure of the request and response data the endpoint url for all rest/soap/simple http requests here are the basic steps to configure a web services server operation: choose an operation type and enter an object name. choose single xml object or single json object as input. (note soap endpoints cannot accept json input data.) choose single xml object or single json object as output. (note that soap endpoints cannot return json data.) ignore profiles for the moment. the result content type is set to application/xml or application/json. save the simple url path for future use. note: if you are using api management, you can define rest and soap api endpoints in api service components. an endpoint derives its default configuration from the web services server connector operation used in the process to which the endpoint is linked, but you can define overrides, including an override for the endpoint url. this lets you expose different sets of endpoints for use by different customers or partners. for more information see the topic about designing apis, linked below. multiple structured objects you can configure a web services server connector operation to group or split like-structured xml and json records in rest/soap/simple http requests and responses (rest/simple http only for json). the xml or json profile definition only needs to contain the base fields for a single object. multiple records can be grouped in the same request or response where the “list” identifier is used as a means to group or split the records. in order for a process to send multiple objects within one client request, you need to perform the following steps: in the web services server operation, in the input type list, select multiple xml objects or multiple json objects. for the request profile, select the xml or json profile that contains the base fields for the request. save and close the operation. redeploy the process. note: if you are using api management, you can set overrides in a rest or soap api endpoint definition in an api service component for the input type and request profile settings in a web services server operation. this example shows how multiple xml objects are structured within one request. consider an xml profile is structured like this: <contact> <firstname></firstname> <lastname></lastname> <email></email> <createdate></createdate> </contact> for soap requests, an platform process accepts requests that contain a list node named <object name> + “list” and parses the data accordingly. here is an example of multiple xml objects in one soap request/response: <soapenv:envelope xmlns:soapenv="http:.xmlsoap.org/soap/envelope/" xmlns:wss="http://www.boomi.com/connector/wss"> <soapenv:header/> <soapenv:body><wss:createcontact> <wss:contactlist> <contact> <firstname>john</firstname> <lastname>doe</lastname> <email>johndoe@abc.com</email> <createdate>01/01/10</createdate> </contact> <contact> <firstname>jane</firstname> <lastname>doe</lastname> <email>janedoe@abc.com</email> <createdate>01/01/10</createdate> </contact> </wss:contactlist> </wss:createcontact> </soapenv:body> </soapenv:envelope> note: note that the “wss” namespace prefixes the object name and list. this is the predefined structure for all soap requests and responses. for http requests, an platform process accepts requests that contain a root node named object name + "list" and parses the data accordingly. here is an example of multiple xml objects in one http request/response: <contactlist> <contact> <firstname>john</firstname> <lastname>doe</lastname> <email>johndoe@abc.com</email> <createdate>01/01/10</createdate> </contact> <contact> <firstname>jane</firstname> <lastname>doe</lastname> <email>janedoe@abc.com</email> <createdate>01/01/10</createdate> </contact> </contactlist> by default, the api process implicitly splits each object record into its own platform document. reviewing the documents in process reporting would show two individual xml documents (for the case above) without any of the request formatting — for example: <?xml version='1.0' encoding='utf-8'?> <contact> <firstname>john</firstname> <lastname>doe</lastname> <email>johndoe@abc.com</email> <createdate>01/01/10</createdate> </contact>