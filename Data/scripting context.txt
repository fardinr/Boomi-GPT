your script needs to work within the platform custom scripting framework to properly read and write documents in the process. a key object to understand is the datacontext object. this object provides methods to allow your script to access the document data and properties from the process execution. conceptually, the custom script will follow this general pattern: (optional) perform any "global" or initialization logic. loop through each document that reached the data process shape. for each document: retrieve the document data from the datacontext into an inputstream object. parse and manipulate the data as required by your use case. convert the modified document data back into an inputstream and store in the datacontext to pass it to the next process step. when you add a custom scripting step, you will get a skeleton script. here is a step-by-step explanation of this skeleton script. import java.util.properties; import java.io.inputstream; // import any additional external java or custom classes to be used in the script. // begin global logic // // perform any initialization logic. this logic will execute once // per step execution, not per document. // end global logic // // loop through the group of documents that reached the data process shape. // note the getdatacount() method provides the count of the number of documents // passed into this step. this may be helpful in initialization logic above. for( int i = 0; i < datacontext.getdatacount(); i++ ) { // the logic here will be executed per document. // retrieve the document data as an inputstream object. inputstream is = datacontext.getstream(i); // retrieve the document's properties a properties object. this includes // connector tracked properties, meta information properties, as well as // user defined document properties. properties props = datacontext.getproperties(i); // begin per document logic // // perform any logic to parse, inspect, manipulate, etc. the document data // and properties here. this is the main part of the script. // end per document logic // // after performing your custom logic, you need to convert the data back // into an inputstream and store it to the datacontext to pass to the next // process step. the number of inputstreams you store will be the number of // documents passed to the next step. datacontext.storestream(is, props); } // end for-each-document for loop within the script you can access process execution information including process properties, the current execution id, and a handle to the process logger, as well as document properties. process execution information can be accessed through the platform scripting api. see accessing process properties with scripting for how to set and retrieve process properties. the process logger allows you to write your own messages to the process log and can be very useful for development and troubleshooting. see the topic about developing and testing scripts for an example. you can also retrieve, modify and create document properties within the script. see accessing document properties with scripting for more information. also see the custom scripting step examples topic.