client applications trigger requests to the apis enabled in integration processes. these applications must initiate the api conversation by sending a rest, soap, odata, or simple http request to a boomi atom. rest requests are supported only for apis defined using api service components. client application requests all rest/soap/odata/simple http requests must be sent to a integration endpoint url. this full url path is managed in two or three places by the api process developer depending on whether an api service component is used to define endpoints: shared web server panel (manage > atom management > settings & configuration > shared web server) — controls the main host name, port and security settings for all atom messaging. web services server connector operation options tab if an api service component is not used to define endpoints, this tab controls the end path for specific data types and operation configurations. if an api service component is used, this tab defines defaults for specific object types and operation configurations. api service component rest tab, soap tab, and/or odata tab — controls the end path for specific object types and operation configurations. overrides can be specified here for the defaults defined in the web services server connector operation. note: if you are exposing an endpoint to service soap requests, but you are not using an api service component, ensure that the endpoint url ends with /ws/soap. if you are using an api service component, depending on the soap version supported, you may need to include either /ws/soap (for soap v1.1) or /ws/soap12 (for soap v1.2) in the endpoint url. boomi atom clouds are currently configured to limit each account to five (5) requests per second per node. on a local atom, the limit is defined by the resources available to the atom. this limit applies to all simple http requests, not only to low latency requests. all input types are managed within the web service server operation built by the integration developer or overridden by the api service component configuration. the input type is limited to one of the following options: none single data single xml object multiple xml objects single json object multiple json objects client application responses all rest/soap/odata/simple http responses can be returned synchronously or asynchronously to the client application. synchronous responses are enabled through use of the return documents step built into the api process. if this functionality is disabled, then the atom web server simply returns "200 ok" as a response receipt when a successful request is made. the supported response/output types are the same as the input types defined above, and an api process can also be developed to support response paging. url and http header matching for routing rest requests the atom applies url and http header matching criteria for the purpose of routing rest requests. base url matching the atom first evaluates the base url specified in a rest request. the request is routed to the api service component whose configured base url is the longest match. for example, consider an atom with these deployed api service components: api service component name base url service a / service b /test service c /test/account requests specifying these base urls would be routed as follows: search:columnrequested base urlrouted to requested base url routed to / service a /test service b /test/other service b /test/account service c /test/account/other service c /other/path service a as demonstrated by the last example, an api service component deployed with / as its configured base url matches any url path that does not match any other base url path. url path matching after matching a rest request to an api service component, the atom then evaluates the requested url path and determines the most specific matching route. url path matching is somewhat more complicated than base url matching in that for a given object and http method there can be multiple rest routes, each with a different path. the atom considers both the length of the path and matching static path components. for example, consider an api service component in which these routes are defined for the same object: get / get /{id} get /{id}/{fieldname} get /{id}/metadata requests specifying these paths would be routed as follows: search:columnrequested url pathrouted to requested url path routed to / get / /1234 get /{id} /1234/name get /{id}/{fieldname} /1234/name/other get /{id}/{fieldname} /1234/metadata get /{id}/metadata as demonstrated by the last example, static path components are more specific matches than parameter values at the same depth. http header matching the atom’s url path matching processing also includes http header matching. the request’s http headers are matched with standard http and “custom” headers defined for operations having the longest, best matching url path. you can, for example, for a given type of operation configure one route to match the header content-type: xml and another route to match the header content-type: json. the headers in a request are evaluated for routing purposes in the same manner as static path components. request parameters url path and http query parameter values can be passed to the web service listener process execution. the values of url path parameters in rest requests are available as dynamic process properties, each with the prefix param_. parameters are delimited by braces {} in the url path for an operation specified for a rest endpoint in an api service component. for example, the parameter id in the url path, specified as {id}, results in the dynamic process property param_id. the values of http query parameters are available as dynamic process properties with the prefix query_ added to each key. for example, the query string ?foo=blah&bar=buzz results in two dynamic process properties, query_foo and query_bar. input headers depending on the shared web server configuration and type of operation, the values of certain “special” http headers and “custom” headers in rest/soap/odata/simple http requests may be available to the web service listener process execution as dynamic document properties. this may occur only for requests for which an input type other than none is configured in the web services server operation. the headers whose values are passed to the execution are those not designated as protected in the shared web server settings. the “special” http headers are search:columnrequest headersentity headers request headers entity headers accept content-encoding — the compression method applied to the data accept-charset content-language accept-encoding content-md5 accept-language content-type — the mime type of any input data, if given the prefix x-wss- is used to designate “custom” headers — for example x-wss-some-info. dynamic document properties sourced as header values have the prefix inheader_ — for example, inheader_content-type, inheader_x-wss-some-info. request metadata for rest and simple http requests, metadata is passed to the web service listener process execution: the http method — for example, get, post — is available as the dynamic process property inmethod. the portion of the endpoint url beginning with the api’s base url, is available as the dynamic process property inpath. the id of the authenticating platform account for the request is available as the dynamic process property inuser. response status codes and output headers for rest and simple http requests with single output document responses: the dynamic document property outstatuscode on the result document overrides the http response status code returned to the client. any dynamic document properties with the prefix outheader_ on the result document are set as headers on the http response returned to the client. for example: outheader_content-type can be used to set the mime type of the return data if a custom type is needed. outheader_some-data results in some-data. disabling low latency process mode for single executions for a process executed with its process mode option set to low latency, the presence in a web server request of the query parameter _boomi_debug=true or the http header x-boomi-debug with a value of true has the effect of changing the process mode to general for the current process execution. this parameter can be useful for debugging purposes.